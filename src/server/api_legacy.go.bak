package server

import (
	"encoding/json"
	"net/http"
	"os/exec"
	"strings"
)

// API endpoints for controlling the UI

func (h *Hub) ServeAPI(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")

	if r.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	switch r.URL.Path {
	case "/api/reload":
		h.handleReload(w, r)
	case "/api/log":
		h.handleLog(w, r)
	case "/api/status":
		h.handleStatus(w, r)
	case "/api/broadcast":
		h.handleBroadcast(w, r)
	case "/api/version":
		h.handleVersion(w, r)
	case "/api/semantic":
		h.handleSemantic(w, r)
	case "/api/natural":
		h.handleNaturalLanguage(w, r)
	case "/api/clients":
		h.handleClients(w, r)
	case "/api/sessions":
		h.handleSessions(w, r)
	default:
		// Check for session detail endpoint like /api/sessions/client_123
		if strings.HasPrefix(r.URL.Path, "/api/sessions/") {
			h.handleSessionDetail(w, r)
		} else {
			http.Error(w, "Not found", http.StatusNotFound)
		}
	}
}

func (h *Hub) handleReload(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	h.ForceReload()
	
	if h.logger != nil {
		h.logger.Log("info", "API", "Force reload triggered", nil)
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": "Reload command sent to all clients",
	})
}

func (h *Hub) handleLog(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var logData struct {
		Level   string      `json:"level"`
		Message string      `json:"message"`
		Data    interface{} `json:"data"`
	}

	if err := json.NewDecoder(r.Body).Decode(&logData); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	h.SendLog(logData.Level, logData.Message, logData.Data)

	if h.logger != nil {
		h.logger.Log(logData.Level, "API", logData.Message, logData.Data)
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": "Log sent to clients",
	})
}

func (h *Hub) handleStatus(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	status := map[string]interface{}{
		"clients_connected": len(h.clients),
		"js_version":       GetJSVersion(),
		"server_running":   true,
	}

	json.NewEncoder(w).Encode(status)
}

func (h *Hub) handleBroadcast(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var message interface{}
	if err := json.NewDecoder(r.Body).Decode(&message); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	messageJSON, _ := json.Marshal(message)
	h.BroadcastMessage(messageJSON)

	if h.logger != nil {
		h.logger.Log("info", "API", "Message broadcasted", message)
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": "Message broadcasted to all clients",
	})
}

func (h *Hub) handleVersion(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "GET":
		json.NewEncoder(w).Encode(map[string]interface{}{
			"version": GetJSVersion(),
		})

	case "POST":
		// Force version update
		updateJSVersion()
		
		// Send version mismatch to all clients to force refresh
		for client := range h.clients {
			response := map[string]interface{}{
				"type": "version_mismatch",
				"server_version": GetJSVersion(),
			}
			responseJSON, _ := json.Marshal(response)
			
			select {
			case client.send <- responseJSON:
			default:
				close(client.send)
				delete(h.clients, client)
			}
		}

		if h.logger != nil {
			h.logger.Log("info", "API", "Version updated, clients refreshing", nil)
		}

		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": true,
			"version": GetJSVersion(),
			"message": "Version updated, clients refreshing",
		})

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (h *Hub) handleSemantic(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var request struct {
		Elements []SemanticElement `json:"elements"`
		Context  LayoutContext     `json:"context"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	// If no context provided, use default
	if request.Context.ScreenWidth == 0 {
		request.Context = LayoutContext{
			ScreenWidth:  1920,
			ScreenHeight: 1080,
			IsMobile:     false,
			IsTouch:      false,
		}
	}

	// Generate semantic UI
	semanticUI := h.CreateSemanticUI(request.Elements, request.Context)
	h.BroadcastMessage(semanticUI)

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": true,
		"message": "Semantic UI created and broadcasted",
	})
}

func (h *Hub) handleNaturalLanguage(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var request struct {
		Description string        `json:"description"`
		Context     LayoutContext `json:"context"`
	}

	if err := json.NewDecoder(r.Body).Decode(&request); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	// Parse natural language to semantic elements
	elements := h.parseNaturalLanguage(request.Description)
	
	if request.Context.ScreenWidth == 0 {
		request.Context = LayoutContext{
			ScreenWidth:  1920,
			ScreenHeight: 1080,
			IsMobile:     false,
			IsTouch:      false,
		}
	}

	semanticUI := h.CreateSemanticUI(elements, request.Context)
	h.BroadcastMessage(semanticUI)

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":  true,
		"message":  "Natural language UI created",
		"elements": elements,
	})
}

func (h *Hub) handleClients(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var clientsInfo []map[string]interface{}
	for client := range h.clients {
		info := map[string]interface{}{
			"connected": true,
			"last_seen": client.lastSeen,
		}
		if client.info != nil {
			info["screen"] = client.info.Screen
			info["capabilities"] = client.info.Capabilities
		}
		clientsInfo = append(clientsInfo, info)
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"clients": clientsInfo,
		"total":   len(h.clients),
	})
}

// Natural language parser - converts descriptions to semantic elements
func (h *Hub) parseNaturalLanguage(description string) []SemanticElement {
	// Simple keyword-based parsing (in real implementation, this would be much more sophisticated)
	elements := []SemanticElement{}
	
	// Common patterns
	if contains(description, "dashboard") {
		elements = append(elements, SemanticElement{
			Type:     "dashboard",
			Intent:   "primary",
			Content:  "System Dashboard",
			Position: "center",
			Behavior: "animated",
		})
	}
	
	if contains(description, "title") || contains(description, "heading") {
		elements = append(elements, SemanticElement{
			Type:     "title",
			Intent:   "primary",
			Content:  "Welcome",
			Size:     "large",
			Position: "top",
		})
	}
	
	if contains(description, "button") {
		intent := "primary"
		if contains(description, "warning") || contains(description, "danger") {
			intent = "warning"
		} else if contains(description, "success") || contains(description, "confirm") {
			intent = "success"
		}
		
		elements = append(elements, SemanticElement{
			Type:     "button",
			Intent:   intent,
			Content:  "Action",
			Size:     "medium",
			Position: "center",
		})
	}
	
	if contains(description, "notification") || contains(description, "alert") {
		intent := "primary"
		if contains(description, "warning") {
			intent = "warning"
		} else if contains(description, "error") {
			intent = "error"
		} else if contains(description, "success") {
			intent = "success"
		}
		
		elements = append(elements, SemanticElement{
			Type:     "notification",
			Intent:   intent,
			Content:  "Notification",
			Position: "floating",
			Behavior: "animated",
		})
	}
	
	if contains(description, "progress") || contains(description, "loading") {
		elements = append(elements, SemanticElement{
			Type:     "progress",
			Intent:   "primary",
			Content:  "Progress",
			Position: "center",
			Data:     map[string]interface{}{"progress": 0.6},
		})
	}
	
	// If no specific elements found, create a default welcome screen
	if len(elements) == 0 {
		elements = []SemanticElement{
			{
				Type:     "title",
				Intent:   "primary",
				Content:  "VisualStream UI",
				Size:     "xl",
				Position: "top",
				Behavior: "animated",
			},
			{
				Type:     "card",
				Intent:   "secondary",
				Content:  "Welcome Card",
				Position: "center",
			},
		}
	}
	
	return elements
}

func contains(text, substr string) bool {
	return len(text) >= len(substr) && 
		   (text == substr || 
		    text[:len(substr)] == substr || 
		    text[len(text)-len(substr):] == substr ||
		    containsSubstring(text, substr))
}

func containsSubstring(text, substr string) bool {
	for i := 0; i <= len(text)-len(substr); i++ {
		if text[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// VWS Sessions API - integrate with shell modules
func (h *Hub) handleSessions(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Execute sessions API shell module
	cmd := exec.Command("/home/claude-3/3dv/modules/sessions_api.sh", "list")
	
	output, err := cmd.Output()
	if err != nil {
		http.Error(w, "Failed to get sessions", http.StatusInternalServerError)
		return
	}

	// Parse JSON output from shell module
	var sessionsData interface{}
	if err := json.Unmarshal(output, &sessionsData); err != nil {
		http.Error(w, "Invalid sessions data", http.StatusInternalServerError)
		return
	}

	// Add server-side client info
	if sessionsMap, ok := sessionsData.(map[string]interface{}); ok {
		sessionsMap["connected_websockets"] = len(h.clients)
		sessionsMap["server_timestamp"] = "now"
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(sessionsData)
}

// Handle individual session details
func (h *Hub) handleSessionDetail(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Extract session ID from URL path
	sessionID := strings.TrimPrefix(r.URL.Path, "/api/sessions/")
	if sessionID == "" {
		http.Error(w, "Session ID required", http.StatusBadRequest)
		return
	}

	// Execute session detail shell command
	cmd := exec.Command("/home/claude-3/3dv/modules/sessions_api.sh", "show", sessionID)
	
	output, err := cmd.Output()
	if err != nil {
		http.Error(w, "Session not found", http.StatusNotFound)
		return
	}

	// Parse and return JSON
	var sessionData interface{}
	if err := json.Unmarshal(output, &sessionData); err != nil {
		http.Error(w, "Invalid session data", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(sessionData)
}