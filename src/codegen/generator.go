package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	
	"gopkg.in/yaml.v3"
)

// OpenAPI Specification Structure
type OpenAPISpec struct {
	OpenAPI string                 `yaml:"openapi"`
	Info    Info                   `yaml:"info"`
	Paths   map[string]PathItem    `yaml:"paths"`
	XCodeGeneration CodeGenConfig  `yaml:"x-code-generation"`
}

type Info struct {
	Title       string `yaml:"title"`
	Description string `yaml:"description"`
	Version     string `yaml:"version"`
}

type PathItem struct {
	Get    *Operation `yaml:"get,omitempty"`
	Post   *Operation `yaml:"post,omitempty"`
	Put    *Operation `yaml:"put,omitempty"`
	Delete *Operation `yaml:"delete,omitempty"`
}

type Operation struct {
	OperationID string   `yaml:"operationId"`
	Tags        []string `yaml:"tags"`
	Summary     string   `yaml:"summary"`
	Description string   `yaml:"description"`
	Parameters  []Parameter `yaml:"parameters,omitempty"`
	RequestBody *RequestBody `yaml:"requestBody,omitempty"`
	Responses   map[string]Response `yaml:"responses"`
	XHandler    string   `yaml:"x-handler"`
	XFunction   string   `yaml:"x-function"`
}

type Parameter struct {
	Name     string `yaml:"name"`
	In       string `yaml:"in"`
	Required bool   `yaml:"required"`
	Schema   Schema `yaml:"schema"`
}

type RequestBody struct {
	Required bool                    `yaml:"required"`
	Content  map[string]MediaType    `yaml:"content"`
}

type MediaType struct {
	Schema Schema `yaml:"schema"`
}

type Response struct {
	Description string               `yaml:"description"`
	Content     map[string]MediaType `yaml:"content,omitempty"`
}

type Schema struct {
	Type    string `yaml:"type"`
	Pattern string `yaml:"pattern,omitempty"`
	Ref     string `yaml:"$ref,omitempty"`
}

type CodeGenConfig struct {
	StrictValidation      bool `yaml:"strict-validation"`
	AutoRouting          bool `yaml:"auto-routing"`
	HandlerValidation    bool `yaml:"handler-validation"`
	FailOnMissingHandlers bool `yaml:"fail-on-missing-handlers"`
}

// Generated Router Template
const routerTemplate = `// ===================================================================
// WARNING: AUTO-GENERATED CODE - DO NOT MODIFY THIS FILE
// ===================================================================
//
// This file is automatically generated from api.yaml specification.
// 
// ‚ö†Ô∏è  CRITICAL WARNING: ALL MANUAL CHANGES WILL BE LOST ‚ö†Ô∏è
//
// ‚Ä¢ This file is regenerated on every build
// ‚Ä¢ Changes made here are NON-PERSISTENT
// ‚Ä¢ Manual modifications will be OVERWRITTEN
// ‚Ä¢ To modify routing: Update api.yaml specification
//
// Generation Command: make generate
// Source File: /opt/holo-deck/src/api.yaml
// Generated: Auto-generated by THD specification-driven development
//
// ===================================================================
// SINGLE SOURCE OF TRUTH: api.yaml drives ALL routing
// ===================================================================
package main

import (
	"net/http"
	"strings"
	"log"
{{range .Imports}}
	"{{.}}"{{end}}
)

// Route represents a single API route
type Route struct {
	Path       string
	Method     string
	Handler    func(http.ResponseWriter, *http.Request)
	OperationID string
}

// APIRouter manages all auto-generated routes
type APIRouter struct {
	routes []Route
	hub    *server.Hub
}

// NewAPIRouter creates router from specification
func NewAPIRouter(hub *server.Hub) *APIRouter {
	router := &APIRouter{hub: hub}
	router.generateRoutes()
	return router
}

// ServeHTTP implements http.Handler interface
func (r *APIRouter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	// Set CORS headers
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
	w.Header().Set("Content-Type", "application/json")

	if req.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	// Route matching with parameter extraction
	path := strings.TrimPrefix(req.URL.Path, "/api")
	for _, route := range r.routes {
		if r.matchRoute(route.Path, path) && route.Method == req.Method {
			log.Printf("API: %s %s -> %s", req.Method, req.URL.Path, route.OperationID)
			route.Handler(w, req)
			return
		}
	}

	// Route not found
	http.Error(w, "API endpoint not found", http.StatusNotFound)
}

// Match route with parameter support (e.g. /sessions/{sessionId})
func (r *APIRouter) matchRoute(pattern, path string) bool {
	patternParts := strings.Split(strings.Trim(pattern, "/"), "/")
	pathParts := strings.Split(strings.Trim(path, "/"), "/")

	if len(patternParts) != len(pathParts) {
		return false
	}

	for i, part := range patternParts {
		if strings.HasPrefix(part, "{") && strings.HasSuffix(part, "}") {
			// Parameter placeholder - matches any value
			continue
		}
		if part != pathParts[i] {
			return false
		}
	}
	return true
}

// AUTO-GENERATED ROUTE DEFINITIONS
func (r *APIRouter) generateRoutes() {
	r.routes = []Route{
{{range .Routes}}
		{
			Path:       "{{.Path}}",
			Method:     "{{.Method}}",
			Handler:    r.{{.HandlerFunc}},
			OperationID: "{{.OperationID}}",
		},{{end}}
	}
}

{{range .HandlerStubs}}
// {{.Comment}}
func (r *APIRouter) {{.FuncName}}(w http.ResponseWriter, req *http.Request) {
	{{.Package}}.{{.FuncName}}Handler(w, req, r.hub)
}
{{end}}
`

// Handler validation and generation
func main() {
	fmt.Println("üß† BRAIN SURGEON CODE GENERATOR - SPEC-DRIVEN DEVELOPMENT")
	fmt.Println("========================================================")

	// Load API specification
	specData, err := os.ReadFile("api.yaml")
	if err != nil {
		log.Fatal("‚ùå FATAL: Cannot read api.yaml - Specification is REQUIRED!")
	}

	var spec OpenAPISpec
	if err := yaml.Unmarshal(specData, &spec); err != nil {
		log.Fatal("‚ùå FATAL: Invalid YAML in api.yaml:", err)
	}

	fmt.Printf("‚úÖ Loaded API Spec: %s v%s\n", spec.Info.Title, spec.Info.Version)
	fmt.Printf("üìä Found %d paths to process\n", len(spec.Paths))

	// Analyze and validate all endpoints
	var routes []RouteInfo
	var handlerStubs []HandlerStub
	var missingHandlers []string
	var imports []string

	for path, pathItem := range spec.Paths {
		operations := map[string]*Operation{
			"GET":    pathItem.Get,
			"POST":   pathItem.Post,
			"PUT":    pathItem.Put,
			"DELETE": pathItem.Delete,
		}

		for method, op := range operations {
			if op == nil {
				continue
			}

			fmt.Printf("üîç Processing: %s %s -> %s\n", method, path, op.OperationID)

			// Validate handler file exists
			if op.XHandler != "" {
				handlerPath := op.XHandler
				if !fileExists(handlerPath) {
					missingHandlers = append(missingHandlers, fmt.Sprintf("%s %s -> %s", method, path, handlerPath))
				}

				// Extract package for import
				if dir := filepath.Dir(handlerPath); dir != "." {
					importPath := fmt.Sprintf("holodeck/%s", strings.ReplaceAll(dir, "/", "/"))
					if !contains(imports, importPath) {
						imports = append(imports, importPath)
					}
				}
			}

			// Generate route info
			routes = append(routes, RouteInfo{
				Path:        strings.TrimPrefix(path, "/api"),
				Method:      method,
				OperationID: op.OperationID,
				HandlerFunc: op.XFunction,
			})

			// Generate handler stub with package info
			handlerDir := filepath.Dir(op.XHandler)
			packageName := strings.Split(handlerDir, "/")[len(strings.Split(handlerDir, "/"))-1]
			handlerStubs = append(handlerStubs, HandlerStub{
				FuncName: op.XFunction,
				Package:  packageName,
				Comment:  fmt.Sprintf("%s %s - %s", method, path, op.Summary),
			})
		}
	}

	// FAIL BUILD if handlers missing and strict mode enabled
	if spec.XCodeGeneration.FailOnMissingHandlers && len(missingHandlers) > 0 {
		fmt.Println("\n‚ùå BUILD FAILURE - MISSING REQUIRED HANDLERS:")
		for _, missing := range missingHandlers {
			fmt.Printf("   üö´ %s\n", missing)
		}
		fmt.Println("\nüí° Create the missing handler files or disable strict validation")
		os.Exit(1)
	}

	// Add server import
	if !contains(imports, "holodeck/server") {
		imports = append(imports, "holodeck/server")
	}

	// Generate router code
	fmt.Printf("\nüèóÔ∏è  Generating auto-router with %d routes...\n", len(routes))

	tmpl := template.Must(template.New("router").Parse(routerTemplate))
	
	routerFile, err := os.Create("auto_router.go")
	if err != nil {
		log.Fatal("‚ùå Cannot create auto_router.go:", err)
	}
	defer routerFile.Close()

	templateData := struct {
		Routes       []RouteInfo
		HandlerStubs []HandlerStub
		Imports      []string
	}{
		Routes:       routes,
		HandlerStubs: handlerStubs,
		Imports:      imports,
	}

	if err := tmpl.Execute(routerFile, templateData); err != nil {
		log.Fatal("‚ùå Template generation failed:", err)
	}

	fmt.Println("‚úÖ SUCCESS: auto_router.go generated")
	fmt.Printf("üìä Generated %d routes\n", len(routes))
	fmt.Printf("üîó Generated %d handler stubs\n", len(handlerStubs))
	
	if len(missingHandlers) > 0 {
		fmt.Printf("‚ö†Ô∏è  WARNING: %d handlers missing (build will continue)\n", len(missingHandlers))
	}

	// Generate THD Client from same spec
	fmt.Println("\nüîß GENERATING THD CLIENT...")
	generateTHDClient(spec, routes)

	fmt.Println("\nüöÄ SPEC-DRIVEN DEVELOPMENT COMPLETE!")
	fmt.Println("   ‚Ä¢ API specification drives all routing")
	fmt.Println("   ‚Ä¢ Handler files validated at build time")
	fmt.Println("   ‚Ä¢ Zero manual route configuration needed")
	fmt.Println("   ‚Ä¢ Change spec = change API automatically")
}

type RouteInfo struct {
	Path        string
	Method      string
	OperationID string
	HandlerFunc string
}

type HandlerStub struct {
	FuncName string
	Package  string
	Comment  string
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

// generateTHDClient creates complete auto-generated Go THD client
func generateTHDClient(spec OpenAPISpec, routes []RouteInfo) {
	clientGoPath := "client/main.go"
	clientBinPath := "../build/bin/thd-client"
	
	// Ensure directory exists
	if err := os.MkdirAll("client", 0755); err != nil {
		log.Printf("‚ùå Failed to create client directory: %v", err)
		return
	}
	
	if err := os.MkdirAll(filepath.Dir(clientBinPath), 0755); err != nil {
		log.Printf("‚ùå Failed to create bin directory: %v", err)
		return
	}
	
	// Generate Go client source
	if err := generateGoClient(clientGoPath, spec, routes); err != nil {
		log.Printf("‚ùå Failed to generate Go client: %v", err)
		return
	}
	
	// Build Go client binary
	if err := buildGoClient(clientGoPath, clientBinPath); err != nil {
		log.Printf("‚ùå Failed to build client binary: %v", err)
		return
	}
	
	fmt.Printf("‚úÖ SUCCESS: thd-client Go binary generated with %d commands\n", len(routes))
}

// generateGoClient creates the Go source code for THD client
func generateGoClient(clientPath string, spec OpenAPISpec, routes []RouteInfo) error {
	clientTemplate := `package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
)

const APIBase = "http://localhost:8080/api"

func main() {
	if len(os.Args) < 2 {
		showHelp()
		return
	}

	command := os.Args[1]
	
	switch command {
{{range .Routes}}	case "{{.CommandName}}":
		{{.FunctionName}}()
{{end}}	case "help":
		showHelp()
	default:
		fmt.Printf("Unknown command: %s\n", command)
		showHelp()
		os.Exit(1)
	}
}

func showHelp() {
	fmt.Println("THD Client - Auto-generated from API specification")
	fmt.Println("Available commands:")
{{range .Routes}}	fmt.Println("  {{.CommandName}} - {{.Method}} {{.Path}}")
{{end}}
}

func makeRequest(method, path string, body interface{}) {
	url := APIBase + path
	
	var reqBody io.Reader
	if body != nil {
		jsonData, err := json.Marshal(body)
		if err != nil {
			fmt.Printf("Error marshaling JSON: %v\n", err)
			os.Exit(1)
		}
		reqBody = bytes.NewBuffer(jsonData)
	}
	
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		fmt.Printf("Error creating request: %v\n", err)
		os.Exit(1)
	}
	
	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("Error making request: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()
	
	responseBody, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading response: %v\n", err)
		os.Exit(1)
	}
	
	// Pretty print JSON
	var jsonData interface{}
	if err := json.Unmarshal(responseBody, &jsonData); err == nil {
		prettyJSON, _ := json.MarshalIndent(jsonData, "", "  ")
		fmt.Println(string(prettyJSON))
	} else {
		fmt.Println(string(responseBody))
	}
}

{{range .Routes}}
func {{.FunctionName}}() {
	{{.Implementation}}
}
{{end}}
`

	// Process routes for template
	type ClientRoute struct {
		CommandName    string
		FunctionName   string
		Method         string
		Path           string
		Implementation string
	}
	
	var clientRoutes []ClientRoute
	for _, route := range routes {
		clientRoute := ClientRoute{
			CommandName:    getCommandName(route),
			FunctionName:   getFunctionName(route),
			Method:         strings.ToUpper(route.Method),
			Path:           route.Path,
			Implementation: generateGoImplementation(route),
		}
		clientRoutes = append(clientRoutes, clientRoute)
	}
	
	tmplData := struct {
		Routes []ClientRoute
	}{
		Routes: clientRoutes,
	}
	
	tmpl, err := template.New("client").Parse(clientTemplate)
	if err != nil {
		return fmt.Errorf("template parse error: %v", err)
	}
	
	file, err := os.Create(clientPath)
	if err != nil {
		return fmt.Errorf("create file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("template execute error: %v", err)
	}
	
	return nil
}

// buildGoClient compiles the Go client source into binary
func buildGoClient(sourcePath, binaryPath string) error {
	cmd := exec.Command("go", "build", "-o", binaryPath, sourcePath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("build failed: %v\nOutput: %s", err, string(output))
	}
	return nil
}

// getCommandName converts route info to command name
func getCommandName(route RouteInfo) string {
	// Convert operationId to kebab-case
	name := route.OperationID
	result := ""
	for i, r := range name {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result += "-"
		}
		result += strings.ToLower(string(r))
	}
	return result
}

// getFunctionName converts route info to Go function name
func getFunctionName(route RouteInfo) string {
	// Convert operationId to camelCase
	name := route.OperationID
	return strings.ToLower(string(name[0])) + name[1:]
}

// generateGoImplementation creates Go code for each route
func generateGoImplementation(route RouteInfo) string {
	method := strings.ToUpper(route.Method)
	path := route.Path
	
	// Count path parameters
	paramCount := strings.Count(path, "{")
	
	if paramCount == 0 {
		// No path parameters
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`makeRequest("%s", "%s", nil)`, method, path)
		} else {
			// POST/PUT with no path params - optional JSON body
			return fmt.Sprintf(`var body interface{}
	if len(os.Args) > 2 {
		if err := json.Unmarshal([]byte(os.Args[2]), &body); err != nil {
			fmt.Printf("Error parsing JSON: %%v\n", err)
			os.Exit(1)
		}
	}
	makeRequest("%s", "%s", body)`, method, path)
		}
	} else if paramCount == 1 {
		// One path parameter
		pathTemplate := strings.Replace(path, "{sessionId}", `" + os.Args[2] + "`, 1)
		pathTemplate = strings.Replace(pathTemplate, "{sceneId}", `" + os.Args[2] + "`, 1)
		pathTemplate = strings.Replace(pathTemplate, "{objectName}", `" + os.Args[2] + "`, 1)
		pathTemplate = `"` + pathTemplate + `"`
		
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`if len(os.Args) < 3 {
		fmt.Println("Error: Missing required parameter")
		os.Exit(1)
	}
	makeRequest("%s", %s, nil)`, method, pathTemplate)
		} else {
			return fmt.Sprintf(`if len(os.Args) < 3 {
		fmt.Println("Error: Missing required parameter")
		os.Exit(1)
	}
	var body interface{}
	if len(os.Args) > 3 {
		if err := json.Unmarshal([]byte(os.Args[3]), &body); err != nil {
			fmt.Printf("Error parsing JSON: %%v\n", err)
			os.Exit(1)
		}
	}
	makeRequest("%s", %s, body)`, method, pathTemplate)
		}
	} else {
		// Two path parameters
		pathTemplate := strings.Replace(path, "{sessionId}", `" + os.Args[2] + "`, 1)
		pathTemplate = strings.Replace(pathTemplate, "{objectName}", `" + os.Args[3] + "`, 1)
		pathTemplate = `"` + pathTemplate + `"`
		
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`if len(os.Args) < 4 {
		fmt.Println("Error: Missing required parameters")
		os.Exit(1)
	}
	makeRequest("%s", %s, nil)`, method, pathTemplate)
		} else {
			return fmt.Sprintf(`if len(os.Args) < 4 {
		fmt.Println("Error: Missing required parameters")
		os.Exit(1)
	}
	var body interface{}
	if len(os.Args) > 4 {
		if err := json.Unmarshal([]byte(os.Args[4]), &body); err != nil {
			fmt.Printf("Error parsing JSON: %%v\n", err)
			os.Exit(1)
		}
	}
	makeRequest("%s", %s, body)`, method, pathTemplate)
		}
	}
}