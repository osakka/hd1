package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	
	"gopkg.in/yaml.v3"
	"holodeck/logging"
)

// OpenAPI Specification Structure
type OpenAPISpec struct {
	OpenAPI string                 `yaml:"openapi"`
	Info    Info                   `yaml:"info"`
	Paths   map[string]PathItem    `yaml:"paths"`
	XCodeGeneration CodeGenConfig  `yaml:"x-code-generation"`
}

type Info struct {
	Title       string `yaml:"title"`
	Description string `yaml:"description"`
	Version     string `yaml:"version"`
}

type PathItem struct {
	Get    *Operation `yaml:"get,omitempty"`
	Post   *Operation `yaml:"post,omitempty"`
	Put    *Operation `yaml:"put,omitempty"`
	Delete *Operation `yaml:"delete,omitempty"`
}

type Operation struct {
	OperationID string   `yaml:"operationId"`
	Tags        []string `yaml:"tags"`
	Summary     string   `yaml:"summary"`
	Description string   `yaml:"description"`
	Parameters  []Parameter `yaml:"parameters,omitempty"`
	RequestBody *RequestBody `yaml:"requestBody,omitempty"`
	Responses   map[string]Response `yaml:"responses"`
	XHandler    string   `yaml:"x-handler"`
	XFunction   string   `yaml:"x-function"`
}

type Parameter struct {
	Name     string `yaml:"name"`
	In       string `yaml:"in"`
	Required bool   `yaml:"required"`
	Schema   Schema `yaml:"schema"`
}

type RequestBody struct {
	Required bool                    `yaml:"required"`
	Content  map[string]MediaType    `yaml:"content"`
}

type MediaType struct {
	Schema Schema `yaml:"schema"`
}

type Response struct {
	Description string               `yaml:"description"`
	Content     map[string]MediaType `yaml:"content,omitempty"`
}

type Schema struct {
	Type    string `yaml:"type"`
	Pattern string `yaml:"pattern,omitempty"`
	Ref     string `yaml:"$ref,omitempty"`
}

type CodeGenConfig struct {
	StrictValidation      bool `yaml:"strict-validation"`
	AutoRouting          bool `yaml:"auto-routing"`
	HandlerValidation    bool `yaml:"handler-validation"`
	FailOnMissingHandlers bool `yaml:"fail-on-missing-handlers"`
}

// Generated Router Template
const routerTemplate = `// ===================================================================
// WARNING: AUTO-GENERATED CODE - DO NOT MODIFY THIS FILE
// ===================================================================
//
// This file is automatically generated from api.yaml specification.
// 
// ‚ö†Ô∏è  CRITICAL WARNING: ALL MANUAL CHANGES WILL BE LOST ‚ö†Ô∏è
//
// ‚Ä¢ This file is regenerated on every build
// ‚Ä¢ Changes made here are NON-PERSISTENT
// ‚Ä¢ Manual modifications will be OVERWRITTEN
// ‚Ä¢ To modify routing: Update api.yaml specification
//
// Generation Command: make generate
// Source File: /opt/holo-deck/src/api.yaml
// Generated: Auto-generated by THD specification-driven development
//
// ===================================================================
// SINGLE SOURCE OF TRUTH: api.yaml drives ALL routing
// ===================================================================
package main

import (
	"net/http"
	"strings"
	"holodeck/logging"
{{range .Imports}}
	{{if eq . "holodeck/api/logging"}}apiLogging "{{.}}"{{else}}"{{.}}"{{end}}{{end}}
)

// Route represents a single API route
type Route struct {
	Path       string
	Method     string
	Handler    func(http.ResponseWriter, *http.Request)
	OperationID string
}

// APIRouter manages all auto-generated routes
type APIRouter struct {
	routes []Route
	hub    *server.Hub
}

// NewAPIRouter creates router from specification
func NewAPIRouter(hub *server.Hub) *APIRouter {
	router := &APIRouter{hub: hub}
	router.generateRoutes()
	return router
}

// ServeHTTP implements http.Handler interface
func (r *APIRouter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	// Set CORS headers
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
	w.Header().Set("Content-Type", "application/json")

	if req.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	// Route matching with parameter extraction
	path := strings.TrimPrefix(req.URL.Path, "/api")
	for _, route := range r.routes {
		if r.matchRoute(route.Path, path) && route.Method == req.Method {
			logging.Debug("API request routed", map[string]interface{}{
				"method": req.Method,
				"path": req.URL.Path,
				"operation_id": route.OperationID,
			})
			route.Handler(w, req)
			return
		}
	}

	// Route not found
	http.Error(w, "API endpoint not found", http.StatusNotFound)
}

// Match route with parameter support (e.g. /sessions/{sessionId})
func (r *APIRouter) matchRoute(pattern, path string) bool {
	patternParts := strings.Split(strings.Trim(pattern, "/"), "/")
	pathParts := strings.Split(strings.Trim(path, "/"), "/")

	if len(patternParts) != len(pathParts) {
		return false
	}

	for i, part := range patternParts {
		if strings.HasPrefix(part, "{") && strings.HasSuffix(part, "}") {
			// Parameter placeholder - matches any value
			continue
		}
		if part != pathParts[i] {
			return false
		}
	}
	return true
}

// AUTO-GENERATED ROUTE DEFINITIONS
func (r *APIRouter) generateRoutes() {
	r.routes = []Route{
{{range .Routes}}
		{
			Path:       "{{.Path}}",
			Method:     "{{.Method}}",
			Handler:    r.{{.HandlerFunc}},
			OperationID: "{{.OperationID}}",
		},{{end}}
	}
}

{{range .HandlerStubs}}
// {{.Comment}}
func (r *APIRouter) {{.FuncName}}(w http.ResponseWriter, req *http.Request) {
	{{if eq .Package "logging"}}apiLogging{{else}}{{.Package}}{{end}}.{{.FuncName}}Handler(w, req, r.hub)
}
{{end}}
`

// Handler validation and generation
func main() {
	fmt.Println("üß† BRAIN SURGEON CODE GENERATOR - SPEC-DRIVEN DEVELOPMENT")
	fmt.Println("========================================================")

	// Initialize logging for code generation
	logging.InitLogger("/opt/holo-deck/build/logs", logging.INFO, []string{})
	logging.Info("code generator starting", map[string]interface{}{
		"task": "specification-driven development",
	})

	// Load API specification
	specData, err := os.ReadFile("api.yaml")
	if err != nil {
		logging.Fatal("cannot read api.yaml specification", map[string]interface{}{
			"error": err.Error(),
			"note": "specification is required for code generation",
		})
	}

	var spec OpenAPISpec
	if err := yaml.Unmarshal(specData, &spec); err != nil {
		logging.Fatal("invalid YAML in api.yaml", map[string]interface{}{
			"error": err.Error(),
		})
	}

	logging.Info("API specification loaded successfully", map[string]interface{}{
		"title": spec.Info.Title,
		"version": spec.Info.Version,
		"total_paths": len(spec.Paths),
	})
	fmt.Printf("‚úÖ Loaded API Spec: %s v%s\n", spec.Info.Title, spec.Info.Version)
	fmt.Printf("üìä Found %d paths to process\n", len(spec.Paths))

	// Analyze and validate all endpoints
	var routes []RouteInfo
	var handlerStubs []HandlerStub
	var missingHandlers []string
	var imports []string

	for path, pathItem := range spec.Paths {
		operations := map[string]*Operation{
			"GET":    pathItem.Get,
			"POST":   pathItem.Post,
			"PUT":    pathItem.Put,
			"DELETE": pathItem.Delete,
		}

		for method, op := range operations {
			if op == nil {
				continue
			}

			fmt.Printf("üîç Processing: %s %s -> %s\n", method, path, op.OperationID)

			// Validate handler file exists
			if op.XHandler != "" {
				handlerPath := op.XHandler
				if !fileExists(handlerPath) {
					missingHandlers = append(missingHandlers, fmt.Sprintf("%s %s -> %s", method, path, handlerPath))
				}

				// Extract package for import
				if dir := filepath.Dir(handlerPath); dir != "." {
					importPath := fmt.Sprintf("holodeck/%s", strings.ReplaceAll(dir, "/", "/"))
					if !contains(imports, importPath) {
						imports = append(imports, importPath)
					}
				}
			}

			// Generate route info
			routes = append(routes, RouteInfo{
				Path:        strings.TrimPrefix(path, "/api"),
				Method:      method,
				OperationID: op.OperationID,
				HandlerFunc: op.XFunction,
			})

			// Generate handler stub with package info
			handlerDir := filepath.Dir(op.XHandler)
			packageName := strings.Split(handlerDir, "/")[len(strings.Split(handlerDir, "/"))-1]
			handlerStubs = append(handlerStubs, HandlerStub{
				FuncName: op.XFunction,
				Package:  packageName,
				Comment:  fmt.Sprintf("%s %s - %s", method, path, op.Summary),
			})
		}
	}

	// FAIL BUILD if handlers missing and strict mode enabled
	if spec.XCodeGeneration.FailOnMissingHandlers && len(missingHandlers) > 0 {
		fmt.Println("\n‚ùå BUILD FAILURE - MISSING REQUIRED HANDLERS:")
		for _, missing := range missingHandlers {
			fmt.Printf("   üö´ %s\n", missing)
		}
		fmt.Println("\nüí° Create the missing handler files or disable strict validation")
		os.Exit(1)
	}

	// Add server import
	if !contains(imports, "holodeck/server") {
		imports = append(imports, "holodeck/server")
	}

	// Generate router code
	fmt.Printf("\nüèóÔ∏è  Generating auto-router with %d routes...\n", len(routes))

	tmpl := template.Must(template.New("router").Parse(routerTemplate))
	
	routerFile, err := os.Create("auto_router.go")
	if err != nil {
		logging.Fatal("failed to create auto_router.go", map[string]interface{}{
			"error": err.Error(),
		})
	}
	defer routerFile.Close()

	templateData := struct {
		Routes       []RouteInfo
		HandlerStubs []HandlerStub
		Imports      []string
	}{
		Routes:       routes,
		HandlerStubs: handlerStubs,
		Imports:      imports,
	}

	if err := tmpl.Execute(routerFile, templateData); err != nil {
		logging.Fatal("template generation failed", map[string]interface{}{
			"error": err.Error(),
		})
	}

	fmt.Println("‚úÖ SUCCESS: auto_router.go generated")
	fmt.Printf("üìä Generated %d routes\n", len(routes))
	fmt.Printf("üîó Generated %d handler stubs\n", len(handlerStubs))
	
	if len(missingHandlers) > 0 {
		fmt.Printf("‚ö†Ô∏è  WARNING: %d handlers missing (build will continue)\n", len(missingHandlers))
	}

	// Generate THD Client from same spec
	fmt.Println("\nüîß GENERATING THD CLIENT...")
	generateTHDClient(spec, routes)

	// Generate Web UI Client - THE CROWN JEWEL
	fmt.Println("\nüëë GENERATING WEB UI CLIENT - THE CROWN JEWEL...")
	generateWebUIClient(spec, routes)

	fmt.Println("\nüöÄ SPEC-DRIVEN DEVELOPMENT COMPLETE!")
	fmt.Println("   ‚Ä¢ API specification drives all routing")
	fmt.Println("   ‚Ä¢ Handler files validated at build time")
	fmt.Println("   ‚Ä¢ Zero manual route configuration needed")
	fmt.Println("   ‚Ä¢ Web UI client auto-generated from spec")
	fmt.Println("   ‚Ä¢ Change spec = change API + UI automatically")
}

type RouteInfo struct {
	Path        string
	Method      string
	OperationID string
	HandlerFunc string
}

type HandlerStub struct {
	FuncName string
	Package  string
	Comment  string
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

// generateTHDClient creates complete auto-generated Go THD client
func generateTHDClient(spec OpenAPISpec, routes []RouteInfo) {
	clientGoPath := "client/main.go"
	clientBinPath := "../build/bin/thd-client"
	
	// Ensure directory exists
	if err := os.MkdirAll("client", 0755); err != nil {
		logging.Error("failed to create client directory", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	if err := os.MkdirAll(filepath.Dir(clientBinPath), 0755); err != nil {
		logging.Error("failed to create bin directory", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Generate Go client source
	if err := generateGoClient(clientGoPath, spec, routes); err != nil {
		logging.Error("failed to generate Go client", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Build Go client binary
	if err := buildGoClient(clientGoPath, clientBinPath); err != nil {
		logging.Error("failed to build client binary", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	fmt.Printf("‚úÖ SUCCESS: thd-client Go binary generated with %d commands\n", len(routes))
}

// generateGoClient creates the Go source code for THD client
func generateGoClient(clientPath string, spec OpenAPISpec, routes []RouteInfo) error {
	clientTemplate := `package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
)

const APIBase = "http://localhost:8080/api"

func main() {
	if len(os.Args) < 2 {
		showHelp()
		return
	}

	command := os.Args[1]
	
	switch command {
{{range .Routes}}	case "{{.CommandName}}":
		{{.FunctionName}}()
{{end}}	case "help":
		showHelp()
	default:
		fmt.Printf("Unknown command: %s\n", command)
		showHelp()
		os.Exit(1)
	}
}

func showHelp() {
	fmt.Println("THD Client - Auto-generated from API specification")
	fmt.Println("Available commands:")
{{range .Routes}}	fmt.Println("  {{.CommandName}} - {{.Method}} {{.Path}}")
{{end}}
}

func makeRequest(method, path string, body interface{}) {
	url := APIBase + path
	
	var reqBody io.Reader
	if body != nil {
		jsonData, err := json.Marshal(body)
		if err != nil {
			fmt.Printf("Error marshaling JSON: %v\n", err)
			os.Exit(1)
		}
		reqBody = bytes.NewBuffer(jsonData)
	}
	
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		fmt.Printf("Error creating request: %v\n", err)
		os.Exit(1)
	}
	
	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}
	
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("Error making request: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()
	
	responseBody, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading response: %v\n", err)
		os.Exit(1)
	}
	
	// Pretty print JSON
	var jsonData interface{}
	if err := json.Unmarshal(responseBody, &jsonData); err == nil {
		prettyJSON, _ := json.MarshalIndent(jsonData, "", "  ")
		fmt.Println(string(prettyJSON))
	} else {
		fmt.Println(string(responseBody))
	}
}

{{range .Routes}}
func {{.FunctionName}}() {
	{{.Implementation}}
}
{{end}}
`

	// Process routes for template
	type ClientRoute struct {
		CommandName    string
		FunctionName   string
		Method         string
		Path           string
		Implementation string
	}
	
	var clientRoutes []ClientRoute
	for _, route := range routes {
		clientRoute := ClientRoute{
			CommandName:    getCommandName(route),
			FunctionName:   getFunctionName(route),
			Method:         strings.ToUpper(route.Method),
			Path:           route.Path,
			Implementation: generateGoImplementation(route),
		}
		clientRoutes = append(clientRoutes, clientRoute)
	}
	
	tmplData := struct {
		Routes []ClientRoute
	}{
		Routes: clientRoutes,
	}
	
	tmpl, err := template.New("client").Parse(clientTemplate)
	if err != nil {
		return fmt.Errorf("template parse error: %v", err)
	}
	
	file, err := os.Create(clientPath)
	if err != nil {
		return fmt.Errorf("create file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("template execute error: %v", err)
	}
	
	return nil
}

// buildGoClient compiles the Go client source into binary
func buildGoClient(sourcePath, binaryPath string) error {
	cmd := exec.Command("go", "build", "-o", binaryPath, sourcePath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("build failed: %v\nOutput: %s", err, string(output))
	}
	return nil
}

// getCommandName converts route info to command name
func getCommandName(route RouteInfo) string {
	// Convert operationId to kebab-case
	name := route.OperationID
	result := ""
	for i, r := range name {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result += "-"
		}
		result += strings.ToLower(string(r))
	}
	return result
}

// getFunctionName converts route info to Go function name
func getFunctionName(route RouteInfo) string {
	// Convert operationId to camelCase
	name := route.OperationID
	return strings.ToLower(string(name[0])) + name[1:]
}

// generateGoImplementation creates Go code for each route
func generateGoImplementation(route RouteInfo) string {
	method := strings.ToUpper(route.Method)
	path := route.Path
	
	// Count path parameters
	paramCount := strings.Count(path, "{")
	
	if paramCount == 0 {
		// No path parameters
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`makeRequest("%s", "%s", nil)`, method, path)
		} else {
			// POST/PUT with no path params - optional JSON body
			return fmt.Sprintf(`var body interface{}
	if len(os.Args) > 2 {
		if err := json.Unmarshal([]byte(os.Args[2]), &body); err != nil {
			fmt.Printf("Error parsing JSON: %%v\n", err)
			os.Exit(1)
		}
	}
	makeRequest("%s", "%s", body)`, method, path)
		}
	} else if paramCount == 1 {
		// One path parameter
		pathTemplate := strings.Replace(path, "{sessionId}", `" + os.Args[2] + "`, 1)
		pathTemplate = strings.Replace(pathTemplate, "{sceneId}", `" + os.Args[2] + "`, 1)
		pathTemplate = strings.Replace(pathTemplate, "{objectName}", `" + os.Args[2] + "`, 1)
		pathTemplate = `"` + pathTemplate + `"`
		
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`if len(os.Args) < 3 {
		fmt.Println("Error: Missing required parameter")
		os.Exit(1)
	}
	makeRequest("%s", %s, nil)`, method, pathTemplate)
		} else {
			return fmt.Sprintf(`if len(os.Args) < 3 {
		fmt.Println("Error: Missing required parameter")
		os.Exit(1)
	}
	var body interface{}
	if len(os.Args) > 3 {
		if err := json.Unmarshal([]byte(os.Args[3]), &body); err != nil {
			fmt.Printf("Error parsing JSON: %%v\n", err)
			os.Exit(1)
		}
	}
	makeRequest("%s", %s, body)`, method, pathTemplate)
		}
	} else {
		// Two path parameters
		pathTemplate := strings.Replace(path, "{sessionId}", `" + os.Args[2] + "`, 1)
		pathTemplate = strings.Replace(pathTemplate, "{objectName}", `" + os.Args[3] + "`, 1)
		pathTemplate = `"` + pathTemplate + `"`
		
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`if len(os.Args) < 4 {
		fmt.Println("Error: Missing required parameters")
		os.Exit(1)
	}
	makeRequest("%s", %s, nil)`, method, pathTemplate)
		} else {
			return fmt.Sprintf(`if len(os.Args) < 4 {
		fmt.Println("Error: Missing required parameters")
		os.Exit(1)
	}
	var body interface{}
	if len(os.Args) > 4 {
		if err := json.Unmarshal([]byte(os.Args[4]), &body); err != nil {
			fmt.Printf("Error parsing JSON: %%v\n", err)
			os.Exit(1)
		}
	}
	makeRequest("%s", %s, body)`, method, pathTemplate)
		}
	}
}

// generateWebUIClient creates the revolutionary auto-generated web UI client
func generateWebUIClient(spec OpenAPISpec, routes []RouteInfo) {
	fmt.Println("üèóÔ∏è  Creating Web UI Generator Infrastructure...")
	
	// Create web UI client directory structure
	uiClientDir := "../share/htdocs/static/js"
	if err := os.MkdirAll(uiClientDir, 0755); err != nil {
		logging.Error("failed to create UI client directory", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Generate JavaScript API Client Library
	if err := generateJavaScriptAPIClient(uiClientDir, spec, routes); err != nil {
		logging.Error("failed to generate JavaScript API client", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Generate UI Component Library
	if err := generateUIComponents(uiClientDir, spec, routes); err != nil {
		logging.Error("failed to generate UI components", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Generate Dynamic Form System
	if err := generateFormSystem(uiClientDir, spec, routes); err != nil {
		logging.Error("failed to generate form system", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	fmt.Printf("‚úÖ SUCCESS: Web UI Client generated with %d API endpoints\n", len(routes))
	fmt.Println("üëë CROWN JEWEL ACHIEVED: 100% Single Source of Truth")
	fmt.Println("   ‚Ä¢ JavaScript API client auto-generated")
	fmt.Println("   ‚Ä¢ UI components auto-generated")
	fmt.Println("   ‚Ä¢ Dynamic forms auto-generated")
	fmt.Println("   ‚Ä¢ Zero manual UI synchronization needed")
}

// generateJavaScriptAPIClient creates the complete JavaScript API wrapper
func generateJavaScriptAPIClient(outputDir string, spec OpenAPISpec, routes []RouteInfo) error {
	apiClientTemplate := `// ===================================================================
// WARNING: AUTO-GENERATED CODE - DO NOT MODIFY THIS FILE
// ===================================================================
//
// This JavaScript API client is automatically generated from api.yaml
// 
// ‚ö†Ô∏è  CRITICAL WARNING: ALL MANUAL CHANGES WILL BE LOST ‚ö†Ô∏è
//
// ‚Ä¢ This file is regenerated on every build
// ‚Ä¢ Changes made here are NON-PERSISTENT  
// ‚Ä¢ Manual modifications will be OVERWRITTEN
// ‚Ä¢ To modify API client: Update api.yaml specification
//
// Generation Command: make generate
// Source File: /opt/holo-deck/src/api.yaml
// Generated: Auto-generated by THD specification-driven development
//
// ===================================================================
// THE CROWN JEWEL: 100% Single Source of Truth API Client
// ===================================================================

class THDAPIClient {
    constructor(baseURL = 'http://localhost:8080/api') {
        this.baseURL = baseURL;
        this.defaultHeaders = {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        };
    }

    // Core HTTP request method with professional error handling
    async request(method, path, data = null, headers = {}) {
        const url = this.baseURL + path;
        const config = {
            method: method.toUpperCase(),
            headers: { ...this.defaultHeaders, ...headers }
        };

        if (data && (method.toUpperCase() === 'POST' || method.toUpperCase() === 'PUT')) {
            config.body = JSON.stringify(data);
        }

        try {
            const response = await fetch(url, config);
            
            // Professional error handling
            if (!response.ok) {
                const errorData = await response.text();
                throw new Error('HTTP ' + response.status + ': ' + errorData);
            }

            // Parse JSON response
            const responseData = await response.json();
            console.log('API Response:', method, path, responseData);
            return responseData;
        } catch (error) {
            console.error('API Error:', method, path, error);
            throw error;
        }
    }

    // Extract path parameters from URL patterns
    extractPathParams(pattern, values) {
        let path = pattern;
        const params = pattern.match(/\{([^}]+)\}/g) || [];
        
        params.forEach((param, index) => {
            const paramName = param.slice(1, -1); // Remove { }
            const value = values[index] || '';
            path = path.replace(param, value);
        });
        
        return path;
    }

{{range .Methods}}
    // {{.Comment}}
    {{.MethodName}}({{.Parameters}}) {
        {{.Implementation}}
    }
{{end}}
}

// Export for use with existing THD A-Frame system
window.THDAPIClient = THDAPIClient;

// Create global API client instance
window.thdAPI = new THDAPIClient();

console.log('üëë THD API Client loaded - Auto-generated from specification');
console.log('Available methods:', Object.getOwnPropertyNames(THDAPIClient.prototype).filter(name => name !== 'constructor'));
`

	// Process routes for JavaScript template
	type JSMethod struct {
		MethodName     string
		Comment        string
		Parameters     string
		Implementation string
	}
	
	var jsMethods []JSMethod
	for _, route := range routes {
		method := JSMethod{
			MethodName:     getJSMethodName(route),
			Comment:        fmt.Sprintf("%s %s - %s", route.Method, route.Path, route.OperationID),
			Parameters:     getJSParameters(route),
			Implementation: generateJSImplementation(route),
		}
		jsMethods = append(jsMethods, method)
	}
	
	tmplData := struct {
		Methods []JSMethod
	}{
		Methods: jsMethods,
	}
	
	tmpl, err := template.New("jsapi").Parse(apiClientTemplate)
	if err != nil {
		return fmt.Errorf("JavaScript API template parse error: %v", err)
	}
	
	apiClientPath := filepath.Join(outputDir, "thd-api-client.js")
	file, err := os.Create(apiClientPath)
	if err != nil {
		return fmt.Errorf("create API client file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("API client template execute error: %v", err)
	}
	
	return nil
}

// generateUIComponents creates auto-generated UI components for each endpoint
func generateUIComponents(outputDir string, spec OpenAPISpec, routes []RouteInfo) error {
	componentTemplate := `// ===================================================================
// AUTO-GENERATED UI COMPONENTS - DO NOT MODIFY
// ===================================================================
//
// Professional UI components auto-generated from OpenAPI specification
// Updates automatically when API specification changes
//
// ===================================================================

class THDUIComponents {
    constructor(apiClient) {
        this.api = apiClient;
        this.components = new Map();
        this.initializeComponents();
    }

    initializeComponents() {
        console.log('üé® Initializing auto-generated UI components...');
{{range .Components}}
        this.components.set('{{.Name}}', this.create{{.ClassName}}Component());
{{end}}
        console.log('‚úÖ UI components initialized');
    }

{{range .Components}}
    // {{.Comment}}
    create{{.ClassName}}Component() {
        return {
            name: '{{.Name}}',
            endpoint: '{{.Endpoint}}',
            method: '{{.Method}}',
            
            render: (containerId) => {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error('Container not found:', containerId);
                    return;
                }
                
                container.innerHTML = '{{.HTML}}';
                this.attachEventListeners('{{.Name}}', container);
            },
            
            execute: async ({{.ExecuteParams}}) => {
                try {
                    const result = await this.api.{{.APIMethod}}({{.APIParams}});
                    this.showResult('{{.Name}}', result);
                    return result;
                } catch (error) {
                    this.showError('{{.Name}}', error);
                    throw error;
                }
            }
        };
    }
{{end}}

    attachEventListeners(componentName, container) {
        const component = this.components.get(componentName);
        if (!component) return;
        
        const form = container.querySelector('form');
        if (form) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(form);
                const data = Object.fromEntries(formData.entries());
                
                try {
                    await component.execute(data);
                } catch (error) {
                    console.error('Component execution failed:', error);
                }
            });
        }
    }

    showResult(componentName, result) {
        const resultDiv = document.getElementById(componentName + '-result');
        if (resultDiv) {
            resultDiv.innerHTML = '<pre class="success">' + JSON.stringify(result, null, 2) + '</pre>';
        }
    }

    showError(componentName, error) {
        const resultDiv = document.getElementById(componentName + '-result');
        if (resultDiv) {
            resultDiv.innerHTML = '<pre class="error">Error: ' + error.message + '</pre>';
        }
    }

    getComponent(name) {
        return this.components.get(name);
    }

    renderAll(containerId) {
        const container = document.getElementById(containerId);
        if (!container) {
            console.error('Container not found:', containerId);
            return;
        }
        
        container.innerHTML = '<h2>THD API Interface</h2>';
        this.components.forEach((component, name) => {
            const div = document.createElement('div');
            div.className = 'component-container';
            div.id = name + '-container';
            container.appendChild(div);
            component.render(name + '-container');
        });
    }
}

// Export for global use
window.THDUIComponents = THDUIComponents;

console.log('üé® THD UI Components loaded - Auto-generated from specification');
`

	// Process routes for UI components
	type UIComponent struct {
		Name         string
		ClassName    string
		Comment      string
		Endpoint     string
		Method       string
		HTML         string
		ExecuteParams string
		APIMethod    string
		APIParams    string
	}
	
	var components []UIComponent
	for _, route := range routes {
		component := UIComponent{
			Name:         getComponentName(route),
			ClassName:    getComponentClassName(route),
			Comment:      fmt.Sprintf("Component for %s %s", route.Method, route.Path),
			Endpoint:     route.Path,
			Method:       route.Method,
			HTML:         generateComponentHTML(route),
			ExecuteParams: getExecuteParams(route),
			APIMethod:    getJSMethodName(route),
			APIParams:    getAPIParams(route),
		}
		components = append(components, component)
	}
	
	tmplData := struct {
		Components []UIComponent
	}{
		Components: components,
	}
	
	tmpl, err := template.New("components").Parse(componentTemplate)
	if err != nil {
		return fmt.Errorf("UI components template parse error: %v", err)
	}
	
	componentsPath := filepath.Join(outputDir, "thd-ui-components.js")
	file, err := os.Create(componentsPath)
	if err != nil {
		return fmt.Errorf("create UI components file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("UI components template execute error: %v", err)
	}
	
	return nil
}

// generateFormSystem creates dynamic form generation system
func generateFormSystem(outputDir string, spec OpenAPISpec, routes []RouteInfo) error {
	formSystemTemplate := `// ===================================================================
// AUTO-GENERATED FORM SYSTEM - DO NOT MODIFY
// ===================================================================
//
// Dynamic form generation system auto-generated from OpenAPI schemas
//
// ===================================================================

class THDFormSystem {
    constructor() {
        this.formSchemas = new Map();
        this.initializeSchemas();
    }

    initializeSchemas() {
        console.log('üìù Initializing auto-generated form schemas...');
{{range .FormSchemas}}
        this.formSchemas.set('{{.Name}}', {{.Schema}});
{{end}}
        console.log('‚úÖ Form schemas initialized');
    }

    generateForm(schemaName, containerId) {
        const schema = this.formSchemas.get(schemaName);
        if (!schema) {
            console.error('Schema not found:', schemaName);
            return;
        }
        
        const container = document.getElementById(containerId);
        if (!container) {
            console.error('Container not found:', containerId);
            return;
        }
        
        const form = this.createFormFromSchema(schema);
        container.appendChild(form);
    }

    createFormFromSchema(schema) {
        const form = document.createElement('form');
        form.className = 'thd-auto-form';
        
        if (schema.title) {
            const title = document.createElement('h3');
            title.textContent = schema.title;
            form.appendChild(title);
        }
        
        Object.entries(schema.fields || {}).forEach(([fieldName, fieldSchema]) => {
            const fieldDiv = document.createElement('div');
            fieldDiv.className = 'form-field';
            
            const label = document.createElement('label');
            label.textContent = fieldSchema.title || fieldName;
            label.setAttribute('for', fieldName);
            
            const input = this.createInputForField(fieldName, fieldSchema);
            
            fieldDiv.appendChild(label);
            fieldDiv.appendChild(input);
            form.appendChild(fieldDiv);
        });
        
        const submitBtn = document.createElement('button');
        submitBtn.type = 'submit';
        submitBtn.textContent = schema.submitText || 'Submit';
        submitBtn.className = 'thd-submit-btn';
        form.appendChild(submitBtn);
        
        return form;
    }

    createInputForField(fieldName, fieldSchema) {
        const input = document.createElement('input');
        input.name = fieldName;
        input.id = fieldName;
        
        switch (fieldSchema.type) {
            case 'string':
                input.type = 'text';
                break;
            case 'number':
                input.type = 'number';
                break;
            case 'boolean':
                input.type = 'checkbox';
                break;
            default:
                input.type = 'text';
        }
        
        if (fieldSchema.required) {
            input.required = true;
        }
        
        if (fieldSchema.placeholder) {
            input.placeholder = fieldSchema.placeholder;
        }
        
        return input;
    }

    getFormData(formElement) {
        const formData = new FormData(formElement);
        const data = {};
        
        for (const [key, value] of formData.entries()) {
            data[key] = value;
        }
        
        return data;
    }
}

// Export for global use
window.THDFormSystem = THDFormSystem;

console.log('üìù THD Form System loaded - Auto-generated from specification');
`

	// Process routes for form schemas
	type FormSchema struct {
		Name   string
		Schema string
	}
	
	var formSchemas []FormSchema
	for _, route := range routes {
		if route.Method == "POST" || route.Method == "PUT" {
			schema := FormSchema{
				Name:   getFormSchemaName(route),
				Schema: generateFormSchemaJSON(route),
			}
			formSchemas = append(formSchemas, schema)
		}
	}
	
	tmplData := struct {
		FormSchemas []FormSchema
	}{
		FormSchemas: formSchemas,
	}
	
	tmpl, err := template.New("forms").Parse(formSystemTemplate)
	if err != nil {
		return fmt.Errorf("form system template parse error: %v", err)
	}
	
	formsPath := filepath.Join(outputDir, "thd-form-system.js")
	file, err := os.Create(formsPath)
	if err != nil {
		return fmt.Errorf("create form system file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("form system template execute error: %v", err)
	}
	
	return nil
}

// Helper functions for JavaScript code generation

func getJSMethodName(route RouteInfo) string {
	// Convert operationId to camelCase for JavaScript
	name := route.OperationID
	return strings.ToLower(string(name[0])) + name[1:]
}

func getJSParameters(route RouteInfo) string {
	// Count path parameters
	paramCount := strings.Count(route.Path, "{")
	
	if paramCount == 0 {
		if route.Method == "POST" || route.Method == "PUT" {
			return "data = null"
		}
		return ""
	} else if paramCount == 1 {
		if route.Method == "POST" || route.Method == "PUT" {
			return "param1, data = null"
		}
		return "param1"
	} else {
		if route.Method == "POST" || route.Method == "PUT" {
			return "param1, param2, data = null"
		}
		return "param1, param2"
	}
}

func generateJSImplementation(route RouteInfo) string {
	method := strings.ToUpper(route.Method)
	path := route.Path
	paramCount := strings.Count(path, "{")
	
	if paramCount == 0 {
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`return this.request('%s', '%s');`, method, path)
		} else {
			return fmt.Sprintf(`return this.request('%s', '%s', data);`, method, path)
		}
	} else if paramCount == 1 {
		pathVar := "this.extractPathParams('" + path + "', [param1])"
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`const path = %s;
        return this.request('%s', path);`, pathVar, method)
		} else {
			return fmt.Sprintf(`const path = %s;
        return this.request('%s', path, data);`, pathVar, method)
		}
	} else {
		pathVar := "this.extractPathParams('" + path + "', [param1, param2])"
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`const path = %s;
        return this.request('%s', path);`, pathVar, method)
		} else {
			return fmt.Sprintf(`const path = %s;
        return this.request('%s', path, data);`, pathVar, method)
		}
	}
}

func getComponentName(route RouteInfo) string {
	return strings.ToLower(route.OperationID)
}

func getComponentClassName(route RouteInfo) string {
	return strings.Title(route.OperationID)
}

func generateComponentHTML(route RouteInfo) string {
	title := strings.Title(strings.ReplaceAll(route.OperationID, "_", " "))
	formId := route.OperationID + "-form"
	resultId := route.OperationID + "-result"
	
	html := fmt.Sprintf(`<div class="thd-component"><h4>%s</h4><form id="%s">`, title, formId)
	
	// Add form fields based on method and path parameters
	paramCount := strings.Count(route.Path, "{")
	if paramCount > 0 {
		html += `<div class="form-field"><label for="param1">Parameter 1:</label><input type="text" name="param1" required></div>`
	}
	if paramCount > 1 {
		html += `<div class="form-field"><label for="param2">Parameter 2:</label><input type="text" name="param2" required></div>`
	}
	
	if route.Method == "POST" || route.Method == "PUT" {
		html += `<div class="form-field"><label for="data">Request Body (JSON):</label><textarea name="data" placeholder="{}"></textarea></div>`
	}
	
	html += fmt.Sprintf(`<button type="submit">Execute</button></form><div id="%s" class="result-area"></div></div>`, resultId)
	
	// Escape for JavaScript string
	html = strings.ReplaceAll(html, "'", "\\'")
	html = strings.ReplaceAll(html, "\n", "")
	
	return html
}

func getExecuteParams(route RouteInfo) string {
	return "formData"
}

func getAPIParams(route RouteInfo) string {
	paramCount := strings.Count(route.Path, "{")
	
	if paramCount == 0 {
		if route.Method == "POST" || route.Method == "PUT" {
			return "formData"
		}
		return ""
	} else if paramCount == 1 {
		if route.Method == "POST" || route.Method == "PUT" {
			return "formData.param1, formData"
		}
		return "formData.param1"
	} else {
		if route.Method == "POST" || route.Method == "PUT" {
			return "formData.param1, formData.param2, formData"
		}
		return "formData.param1, formData.param2"
	}
}

func getFormSchemaName(route RouteInfo) string {
	return route.OperationID + "Form"
}

func generateFormSchemaJSON(route RouteInfo) string {
	title := strings.Title(strings.ReplaceAll(route.OperationID, "_", " "))
	
	schema := fmt.Sprintf(`{
        "title": "%s",
        "submitText": "Execute %s",
        "fields": {`, title, route.Method)
	
	// Add path parameter fields
	paramCount := strings.Count(route.Path, "{")
	fields := []string{}
	
	if paramCount > 0 {
		fields = append(fields, `"param1": {"type": "string", "title": "Parameter 1", "required": true}`)
	}
	if paramCount > 1 {
		fields = append(fields, `"param2": {"type": "string", "title": "Parameter 2", "required": true}`)
	}
	
	if route.Method == "POST" || route.Method == "PUT" {
		fields = append(fields, `"data": {"type": "string", "title": "Request Body (JSON)", "placeholder": "{}"}`)
	}
	
	schema += strings.Join(fields, ", ")
	schema += "}}"
	
	return schema
}