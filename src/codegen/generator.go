package main

import (
	"embed"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	
	"gopkg.in/yaml.v3"
	"holodeck1/logging"
)

//go:embed templates/*
var templateFS embed.FS

// Template cache for performance
var templateCache = make(map[string]*template.Template)

// OpenAPI Specification Structure
type OpenAPISpec struct {
	OpenAPI string                 `yaml:"openapi"`
	Info    Info                   `yaml:"info"`
	Paths   map[string]PathItem    `yaml:"paths"`
	XCodeGeneration CodeGenConfig  `yaml:"x-code-generation"`
}

type Info struct {
	Title       string `yaml:"title"`
	Description string `yaml:"description"`
	Version     string `yaml:"version"`
}

type PathItem struct {
	Get    *Operation `yaml:"get,omitempty"`
	Post   *Operation `yaml:"post,omitempty"`
	Put    *Operation `yaml:"put,omitempty"`
	Delete *Operation `yaml:"delete,omitempty"`
}

type Operation struct {
	OperationID string   `yaml:"operationId"`
	Tags        []string `yaml:"tags"`
	Summary     string   `yaml:"summary"`
	Description string   `yaml:"description"`
	Parameters  []Parameter `yaml:"parameters,omitempty"`
	RequestBody *RequestBody `yaml:"requestBody,omitempty"`
	Responses   map[string]Response `yaml:"responses"`
	XHandler    string   `yaml:"x-handler"`
	XFunction   string   `yaml:"x-function"`
}

type Parameter struct {
	Name     string `yaml:"name"`
	In       string `yaml:"in"`
	Required bool   `yaml:"required"`
	Schema   Schema `yaml:"schema"`
}

type RequestBody struct {
	Required bool                    `yaml:"required"`
	Content  map[string]MediaType    `yaml:"content"`
}

type MediaType struct {
	Schema Schema `yaml:"schema"`
}

type Response struct {
	Description string               `yaml:"description"`
	Content     map[string]MediaType `yaml:"content,omitempty"`
}

type Schema struct {
	Type    string `yaml:"type"`
	Pattern string `yaml:"pattern,omitempty"`
	Ref     string `yaml:"$ref,omitempty"`
}

type CodeGenConfig struct {
	StrictValidation      bool `yaml:"strict-validation"`
	AutoRouting          bool `yaml:"auto-routing"`
	HandlerValidation    bool `yaml:"handler-validation"`
	FailOnMissingHandlers bool `yaml:"fail-on-missing-handlers"`
}

// loadTemplate loads and caches a template from the embedded filesystem
func loadTemplate(templatePath string) (*template.Template, error) {
	if tmpl, exists := templateCache[templatePath]; exists {
		return tmpl, nil
	}
	
	content, err := templateFS.ReadFile(templatePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read template %s: %w", templatePath, err)
	}
	
	tmpl, err := template.New(filepath.Base(templatePath)).Parse(string(content))
	if err != nil {
		return nil, fmt.Errorf("failed to parse template %s: %w", templatePath, err)
	}
	
	templateCache[templatePath] = tmpl
	return tmpl, nil
}

// DEPRECATED: Legacy hardcoded template - replaced by external file
const routerTemplate = `// ===================================================================
// WARNING: AUTO-GENERATED CODE - DO NOT MODIFY THIS FILE
// ===================================================================
//
// This file is automatically generated from api.yaml specification.
// 
// ⚠️  CRITICAL WARNING: ALL MANUAL CHANGES WILL BE LOST ⚠️
//
// • This file is regenerated on every build
// • Changes made here are NON-PERSISTENT
// • Manual modifications will be OVERWRITTEN
// • To modify routing: Update api.yaml specification
//
// Generation Command: make generate
// Source File: /opt/hd1/src/api.yaml
// Generated: Auto-generated by HD1 specification-driven development
//
// ===================================================================
// SINGLE SOURCE OF TRUTH: api.yaml drives ALL routing
// ===================================================================
package main

import (
	"net/http"
	"strings"
	"holodeck1/logging"
{{range .Imports}}
	{{if eq . "holodeck1/api/logging"}}apiLogging "{{.}}"{{else}}"{{.}}"{{end}}{{end}}
)

// Route represents a single API route
type Route struct {
	Path       string
	Method     string
	Handler    func(http.ResponseWriter, *http.Request)
	OperationID string
}

// APIRouter manages all auto-generated routes
type APIRouter struct {
	routes []Route
	hub    *server.Hub
}

// NewAPIRouter creates router from specification
func NewAPIRouter(hub *server.Hub) *APIRouter {
	router := &APIRouter{hub: hub}
	router.generateRoutes()
	return router
}

// ServeHTTP implements http.Handler interface
func (r *APIRouter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	// Set CORS headers
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
	w.Header().Set("Content-Type", "application/json")

	if req.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	// Route matching with parameter extraction
	path := strings.TrimPrefix(req.URL.Path, "/api")
	for _, route := range r.routes {
		if r.matchRoute(route.Path, path) && route.Method == req.Method {
			logging.Debug("API request routed", map[string]interface{}{
				"method": req.Method,
				"path": req.URL.Path,
				"operation_id": route.OperationID,
			})
			route.Handler(w, req)
			return
		}
	}

	// Route not found
	http.Error(w, "API endpoint not found", http.StatusNotFound)
}

// Match route with parameter support (e.g. /sessions/{sessionId})
func (r *APIRouter) matchRoute(pattern, path string) bool {
	patternParts := strings.Split(strings.Trim(pattern, "/"), "/")
	pathParts := strings.Split(strings.Trim(path, "/"), "/")

	if len(patternParts) != len(pathParts) {
		return false
	}

	for i, part := range patternParts {
		if strings.HasPrefix(part, "{") && strings.HasSuffix(part, "}") {
			// Parameter placeholder - matches any value
			continue
		}
		if part != pathParts[i] {
			return false
		}
	}
	return true
}

// AUTO-GENERATED ROUTE DEFINITIONS
func (r *APIRouter) generateRoutes() {
	r.routes = []Route{
{{range .Routes}}
		{
			Path:       "{{.Path}}",
			Method:     "{{.Method}}",
			Handler:    r.{{.HandlerFunc}},
			OperationID: "{{.OperationID}}",
		},{{end}}
	}
}

{{range .HandlerStubs}}
// {{.Comment}}
func (r *APIRouter) {{.FuncName}}(w http.ResponseWriter, req *http.Request) {
	{{if eq .Package "logging"}}apiLogging{{else}}{{.Package}}{{end}}.{{.FuncName}}Handler(w, req, r.hub)
}
{{end}}
`

// Handler validation and generation
func main() {
	fmt.Println("HD1 Code Generator - Upstream/Downstream Integration")
	fmt.Println("======================================================")

	// Initialize logging for code generation
	logging.InitLogger("/opt/hd1/build/logs", logging.INFO, []string{})
	logging.Info("advanced code generator starting", map[string]interface{}{
		"task": "upstream-downstream-integration",
		"single_source_of_truth": true,
	})

	// Load API specification
	specData, err := os.ReadFile("api.yaml")
	if err != nil {
		logging.Fatal("cannot read api.yaml specification", map[string]interface{}{
			"error": err.Error(),
			"note": "specification is required for code generation",
		})
	}

	var spec OpenAPISpec
	if err := yaml.Unmarshal(specData, &spec); err != nil {
		logging.Fatal("invalid YAML in api.yaml", map[string]interface{}{
			"error": err.Error(),
		})
	}

	logging.Info("API specification loaded successfully", map[string]interface{}{
		"title": spec.Info.Title,
		"version": spec.Info.Version,
		"total_paths": len(spec.Paths),
	})
	fmt.Printf("Loaded API Spec: %s v%s\n", spec.Info.Title, spec.Info.Version)
	fmt.Printf("Found %d paths to process\n", len(spec.Paths))

	// Analyze and validate all endpoints
	var routes []RouteInfo
	var handlerStubs []HandlerStub
	var missingHandlers []string
	var imports []string

	for path, pathItem := range spec.Paths {
		operations := map[string]*Operation{
			"GET":    pathItem.Get,
			"POST":   pathItem.Post,
			"PUT":    pathItem.Put,
			"DELETE": pathItem.Delete,
		}

		for method, op := range operations {
			if op == nil {
				continue
			}

			fmt.Printf("Processing: %s %s -> %s\n", method, path, op.OperationID)

			// Validate handler file exists
			if op.XHandler != "" {
				handlerPath := op.XHandler
				if !fileExists(handlerPath) {
					missingHandlers = append(missingHandlers, fmt.Sprintf("%s %s -> %s", method, path, handlerPath))
				}

				// Extract package for import
				if dir := filepath.Dir(handlerPath); dir != "." {
					importPath := fmt.Sprintf("holodeck1/%s", strings.ReplaceAll(dir, "/", "/"))
					if !contains(imports, importPath) {
						imports = append(imports, importPath)
					}
				}
			}

			// Generate route info
			routes = append(routes, RouteInfo{
				Path:        strings.TrimPrefix(path, "/api"),
				Method:      method,
				OperationID: op.OperationID,
				HandlerFunc: op.XFunction,
			})

			// Generate handler stub with package info
			handlerDir := filepath.Dir(op.XHandler)
			packageName := strings.Split(handlerDir, "/")[len(strings.Split(handlerDir, "/"))-1]
			handlerStubs = append(handlerStubs, HandlerStub{
				FuncName: op.XFunction,
				Package:  packageName,
				Comment:  fmt.Sprintf("%s %s - %s", method, path, op.Summary),
			})
		}
	}

	// FAIL BUILD if handlers missing and strict mode enabled
	if spec.XCodeGeneration.FailOnMissingHandlers && len(missingHandlers) > 0 {
		fmt.Println("\nBuild Failure - Missing Required Handlers:")
		for _, missing := range missingHandlers {
			fmt.Printf("   Missing: %s\n", missing)
		}
		fmt.Println("\nCreate the missing handler files or disable strict validation")
		os.Exit(1)
	}

	// Add server import
	if !contains(imports, "holodeck1/server") {
		imports = append(imports, "holodeck1/server")
	}

	// Generate router code
	fmt.Printf("\nGenerating auto-router with %d routes...\n", len(routes))

	tmpl, err := loadTemplate("templates/go/router.tmpl")
	if err != nil {
		logging.Fatal("failed to load router template", map[string]interface{}{
			"error": err.Error(),
		})
	}
	
	routerFile, err := os.Create("auto_router.go")
	if err != nil {
		logging.Fatal("failed to create auto_router.go", map[string]interface{}{
			"error": err.Error(),
		})
	}
	defer routerFile.Close()

	templateData := struct {
		Routes       []RouteInfo
		HandlerStubs []HandlerStub
		Imports      []string
	}{
		Routes:       routes,
		HandlerStubs: handlerStubs,
		Imports:      imports,
	}

	if err := tmpl.Execute(routerFile, templateData); err != nil {
		logging.Fatal("template generation failed", map[string]interface{}{
			"error": err.Error(),
		})
	}

	fmt.Println("auto_router.go generated successfully")
	fmt.Printf("Generated %d routes\n", len(routes))
	fmt.Printf("Generated %d handler stubs\n", len(handlerStubs))
	
	if len(missingHandlers) > 0 {
		fmt.Printf("Warning: %d handlers missing (build will continue)\n", len(missingHandlers))
	}

	// Generate HD1 Client from same spec
	fmt.Println("\nGenerating HD1 client...")
	generateHD1Client(spec, routes)

	// Generate Web UI Client
	fmt.Println("\nGenerating Web UI client...")
	generateWebUIClient(spec, routes)

	// Generate core shell functions from API specification
	fmt.Println("\nGenerating core shell functions from API spec...")
	if err := generateCoreShellFunctions(&spec, routes); err != nil {
		logging.Error("core shell function generation failed", map[string]interface{}{
			"error": err.Error(),
		})
		fmt.Printf("Warning: Core shell function generation failed: %v\n", err)
	} else {
		fmt.Printf("Core shell functions generated from API specification\n")
		fmt.Printf("Generated: /opt/hd1/lib/hd1lib.sh (upstream core library)\n")
	}

	// Advanced enhanced generation with A-Frame integration
	fmt.Println("\nGenerating A-Frame integration...")
	if err := generateEnhancedIntegration(spec, routes); err != nil {
		logging.Error("enhanced integration generation failed", map[string]interface{}{
			"error": err.Error(),
		})
		fmt.Printf("Warning: Enhanced generation failed: %v\n", err)
	} else {
		fmt.Printf("A-Frame integration generated successfully\n")
		fmt.Printf("Shell: A-Frame shell integration: /opt/hd1/lib/downstream/aframelib.sh\n")
		fmt.Printf("JavaScript: A-Frame JavaScript bridge: /opt/hd1/lib/downstream/aframelib.js\n")
	}

	fmt.Println("\nCode generation complete")
	fmt.Println("   • Standard generation: API specification drives all routing")
	fmt.Println("   • Core shell functions: Auto-generated from API spec (SINGLE SOURCE)")
	fmt.Println("   • Enhanced generation: A-Frame schemas drive function bridge")
	fmt.Println("   • Upstream APIs: Shell + JavaScript + CLI identical signatures")
	fmt.Println("   • Downstream APIs: A-Frame + WebXR seamless integration")
	fmt.Println("   • Zero manual route configuration needed")
	fmt.Println("   • Web UI client auto-generated from spec")
	fmt.Println("   • Change spec = change API + UI + shell functions automatically")
}

type RouteInfo struct {
	Path        string
	Method      string
	OperationID string
	HandlerFunc string
}

type HandlerStub struct {
	FuncName string
	Package  string
	Comment  string
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

// generateHD1Client creates complete auto-generated Go HD1 client
func generateHD1Client(spec OpenAPISpec, routes []RouteInfo) {
	clientGoPath := "client/main.go"
	clientBinPath := "../build/bin/hd1-client"
	
	// Ensure directory exists
	if err := os.MkdirAll("client", 0755); err != nil {
		logging.Error("failed to create client directory", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	if err := os.MkdirAll(filepath.Dir(clientBinPath), 0755); err != nil {
		logging.Error("failed to create bin directory", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Generate Go client source
	if err := generateGoClient(clientGoPath, spec, routes); err != nil {
		logging.Error("failed to generate Go client", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Build Go client binary
	if err := buildGoClient(clientGoPath, clientBinPath); err != nil {
		logging.Error("failed to build client binary", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	fmt.Printf("hd1-client Go binary generated with %d commands\n", len(routes))
}

// generateGoClient creates the Go source code for HD1 client
func generateGoClient(clientPath string, spec OpenAPISpec, routes []RouteInfo) error {

	// Process routes for template
	type ClientRoute struct {
		CommandName    string
		FunctionName   string
		Method         string
		Path           string
		Implementation string
	}
	
	var clientRoutes []ClientRoute
	for _, route := range routes {
		clientRoute := ClientRoute{
			CommandName:    getCommandName(route),
			FunctionName:   getFunctionName(route),
			Method:         strings.ToUpper(route.Method),
			Path:           route.Path,
			Implementation: generateGoImplementation(route),
		}
		clientRoutes = append(clientRoutes, clientRoute)
	}
	
	tmplData := struct {
		Routes []ClientRoute
	}{
		Routes: clientRoutes,
	}
	
	tmpl, err := loadTemplate("templates/go/client.tmpl")
	if err != nil {
		return fmt.Errorf("failed to load client template: %w", err)
	}
	
	file, err := os.Create(clientPath)
	if err != nil {
		return fmt.Errorf("create file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("template execute error: %v", err)
	}
	
	return nil
}

// buildGoClient compiles the Go client source into binary
func buildGoClient(sourcePath, binaryPath string) error {
	cmd := exec.Command("go", "build", "-o", binaryPath, sourcePath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("build failed: %v\nOutput: %s", err, string(output))
	}
	return nil
}

// getCommandName converts route info to command name
func getCommandName(route RouteInfo) string {
	// Convert operationId to kebab-case
	name := route.OperationID
	result := ""
	for i, r := range name {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result += "-"
		}
		result += strings.ToLower(string(r))
	}
	return result
}

// getFunctionName converts route info to Go function name
func getFunctionName(route RouteInfo) string {
	// Convert operationId to camelCase
	name := route.OperationID
	return strings.ToLower(string(name[0])) + name[1:]
}

// generateGoImplementation creates Go code for each route with dynamic parameter handling
func generateGoImplementation(route RouteInfo) string {
	method := strings.ToUpper(route.Method)
	path := route.Path
	
	// Extract all path parameters dynamically
	params := extractPathParameters(path)
	paramCount := len(params)
	
	if paramCount == 0 {
		// No path parameters
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`makeRequest("%s", "%s", nil)`, method, path)
		} else {
			// POST/PUT with no path params - optional JSON body
			return fmt.Sprintf(`var body interface{}
	if len(os.Args) > 2 {
		if err := json.Unmarshal([]byte(os.Args[2]), &body); err != nil {
			fmt.Printf("Error parsing JSON: %%v\n", err)
			os.Exit(1)
		}
	}
	makeRequest("%s", "%s", body)`, method, path)
		}
	} else {
		// Dynamic path parameter substitution
		pathTemplate := buildPathTemplate(path, params)
		minArgsRequired := 1 + paramCount + 1 // program + command + params
		bodyArgIndex := minArgsRequired // body is after all required args
		
		argCheckStr := fmt.Sprintf("len(os.Args) < %d", minArgsRequired)
		errorMsg := "Missing required parameter"
		if paramCount > 1 {
			errorMsg = "Missing required parameters"
		}
		
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`if %s {
		fmt.Println("Error: %s")
		os.Exit(1)
	}
	makeRequest("%s", %s, nil)`, argCheckStr, errorMsg, method, pathTemplate)
		} else {
			return fmt.Sprintf(`if %s {
		fmt.Println("Error: %s")
		os.Exit(1)
	}
	var body interface{}
	if len(os.Args) > %d {
		if err := json.Unmarshal([]byte(os.Args[%d]), &body); err != nil {
			fmt.Printf("Error parsing JSON: %%v\n", err)
			os.Exit(1)
		}
	}
	makeRequest("%s", %s, body)`, argCheckStr, errorMsg, minArgsRequired-1, bodyArgIndex, method, pathTemplate)
		}
	}
}

// extractPathParameters extracts all path parameters from a URL path
func extractPathParameters(path string) []string {
	var params []string
	start := 0
	for {
		openIndex := strings.Index(path[start:], "{")
		if openIndex == -1 {
			break
		}
		openIndex += start
		closeIndex := strings.Index(path[openIndex:], "}")
		if closeIndex == -1 {
			break
		}
		closeIndex += openIndex
		param := path[openIndex+1 : closeIndex]
		params = append(params, param)
		start = closeIndex + 1
	}
	return params
}

// buildPathTemplate creates Go string concatenation for dynamic path building
func buildPathTemplate(path string, params []string) string {
	template := `"` + path + `"`
	
	// Replace each parameter with os.Args substitution
	for i, param := range params {
		argIndex := 2 + i // os.Args[0] = program, os.Args[1] = command, os.Args[2+] = params
		placeholder := "{" + param + "}"
		replacement := `" + os.Args[` + fmt.Sprintf("%d", argIndex) + `] + "`
		template = strings.Replace(template, placeholder, replacement, 1)
	}
	
	return template
}

// generateWebUIClient creates the advanced auto-generated web UI client
func generateWebUIClient(spec OpenAPISpec, routes []RouteInfo) {
	fmt.Println("🏗️  Creating Web UI Generator Infrastructure...")
	
	// Create web UI client directory structure
	uiClientDir := "../share/htdocs/static/js"
	if err := os.MkdirAll(uiClientDir, 0755); err != nil {
		logging.Error("failed to create UI client directory", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Generate JavaScript API Client Library
	if err := generateJavaScriptAPIClient(uiClientDir, spec, routes); err != nil {
		logging.Error("failed to generate JavaScript API client", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Generate UI Component Library
	if err := generateUIComponents(uiClientDir, spec, routes); err != nil {
		logging.Error("failed to generate UI components", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	// Generate Dynamic Form System
	if err := generateFormSystem(uiClientDir, spec, routes); err != nil {
		logging.Error("failed to generate form system", map[string]interface{}{
			"error": err.Error(),
		})
		return
	}
	
	fmt.Printf("Web UI Client generated with %d API endpoints\n", len(routes))
	fmt.Println("Single source of truth achieved")
	fmt.Println("   • JavaScript API client auto-generated")
	fmt.Println("   • UI components auto-generated")
	fmt.Println("   • Dynamic forms auto-generated")
	fmt.Println("   • Zero manual UI synchronization needed")
}

// generateJavaScriptAPIClient creates the complete JavaScript API wrapper
func generateJavaScriptAPIClient(outputDir string, spec OpenAPISpec, routes []RouteInfo) error {

	// Process routes for JavaScript template
	type JSMethod struct {
		MethodName     string
		Comment        string
		Parameters     string
		Implementation string
	}
	
	var jsMethods []JSMethod
	for _, route := range routes {
		method := JSMethod{
			MethodName:     getJSMethodName(route),
			Comment:        fmt.Sprintf("%s %s - %s", route.Method, route.Path, route.OperationID),
			Parameters:     getJSParameters(route),
			Implementation: generateJSImplementation(route),
		}
		jsMethods = append(jsMethods, method)
	}
	
	tmplData := struct {
		Methods []JSMethod
	}{
		Methods: jsMethods,
	}
	
	tmpl, err := loadTemplate("templates/javascript/api-client.tmpl")
	if err != nil {
		return fmt.Errorf("failed to load JavaScript API template: %w", err)
	}
	
	apiClientPath := filepath.Join(outputDir, "hd1lib.js")
	file, err := os.Create(apiClientPath)
	if err != nil {
		return fmt.Errorf("create API client file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("API client template execute error: %v", err)
	}
	
	return nil
}

// generateUIComponents creates auto-generated UI components for each endpoint
func generateUIComponents(outputDir string, spec OpenAPISpec, routes []RouteInfo) error {

	// Process routes for UI components
	type UIComponent struct {
		Name         string
		ClassName    string
		Comment      string
		Endpoint     string
		Method       string
		HTML         string
		ExecuteParams string
		APIMethod    string
		APIParams    string
	}
	
	var components []UIComponent
	for _, route := range routes {
		component := UIComponent{
			Name:         getComponentName(route),
			ClassName:    getComponentClassName(route),
			Comment:      fmt.Sprintf("Component for %s %s", route.Method, route.Path),
			Endpoint:     route.Path,
			Method:       route.Method,
			HTML:         generateComponentHTML(route),
			ExecuteParams: getExecuteParams(route),
			APIMethod:    getJSMethodName(route),
			APIParams:    getAPIParams(route),
		}
		components = append(components, component)
	}
	
	tmplData := struct {
		Components []UIComponent
	}{
		Components: components,
	}
	
	tmpl, err := loadTemplate("templates/javascript/ui-components.tmpl")
	if err != nil {
		return fmt.Errorf("failed to load UI components template: %w", err)
	}
	
	componentsPath := filepath.Join(outputDir, "hd1-ui-components.js")
	file, err := os.Create(componentsPath)
	if err != nil {
		return fmt.Errorf("create UI components file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("UI components template execute error: %v", err)
	}
	
	return nil
}

// generateFormSystem creates dynamic form generation system
func generateFormSystem(outputDir string, spec OpenAPISpec, routes []RouteInfo) error {

	// Process routes for form schemas
	type FormSchema struct {
		Name   string
		Schema string
	}
	
	var formSchemas []FormSchema
	for _, route := range routes {
		if route.Method == "POST" || route.Method == "PUT" {
			schema := FormSchema{
				Name:   getFormSchemaName(route),
				Schema: generateFormSchemaJSON(route),
			}
			formSchemas = append(formSchemas, schema)
		}
	}
	
	tmplData := struct {
		FormSchemas []FormSchema
	}{
		FormSchemas: formSchemas,
	}
	
	tmpl, err := loadTemplate("templates/javascript/form-system.tmpl")
	if err != nil {
		return fmt.Errorf("form system template load error: %v", err)
	}
	
	formsPath := filepath.Join(outputDir, "hd1-form-system.js")
	file, err := os.Create(formsPath)
	if err != nil {
		return fmt.Errorf("create form system file error: %v", err)
	}
	defer file.Close()
	
	if err := tmpl.Execute(file, tmplData); err != nil {
		return fmt.Errorf("form system template execute error: %v", err)
	}
	
	return nil
}

// Helper functions for JavaScript code generation

func getJSMethodName(route RouteInfo) string {
	// Convert operationId to camelCase for JavaScript
	name := route.OperationID
	return strings.ToLower(string(name[0])) + name[1:]
}

func getJSParameters(route RouteInfo) string {
	// Count path parameters
	paramCount := strings.Count(route.Path, "{")
	
	if paramCount == 0 {
		if route.Method == "POST" || route.Method == "PUT" {
			return "data = null"
		}
		return ""
	} else if paramCount == 1 {
		if route.Method == "POST" || route.Method == "PUT" {
			return "param1, data = null"
		}
		return "param1"
	} else {
		if route.Method == "POST" || route.Method == "PUT" {
			return "param1, param2, data = null"
		}
		return "param1, param2"
	}
}

func generateJSImplementation(route RouteInfo) string {
	method := strings.ToUpper(route.Method)
	path := route.Path
	paramCount := strings.Count(path, "{")
	
	if paramCount == 0 {
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`return this.request('%s', '%s');`, method, path)
		} else {
			return fmt.Sprintf(`return this.request('%s', '%s', data);`, method, path)
		}
	} else if paramCount == 1 {
		pathVar := "this.extractPathParams('" + path + "', [param1])"
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`const path = %s;
        return this.request('%s', path);`, pathVar, method)
		} else {
			return fmt.Sprintf(`const path = %s;
        return this.request('%s', path, data);`, pathVar, method)
		}
	} else {
		pathVar := "this.extractPathParams('" + path + "', [param1, param2])"
		if method == "GET" || method == "DELETE" {
			return fmt.Sprintf(`const path = %s;
        return this.request('%s', path);`, pathVar, method)
		} else {
			return fmt.Sprintf(`const path = %s;
        return this.request('%s', path, data);`, pathVar, method)
		}
	}
}

func getComponentName(route RouteInfo) string {
	return strings.ToLower(route.OperationID)
}

func getComponentClassName(route RouteInfo) string {
	return strings.Title(route.OperationID)
}

func generateComponentHTML(route RouteInfo) string {
	title := strings.Title(strings.ReplaceAll(route.OperationID, "_", " "))
	formId := route.OperationID + "-form"
	resultId := route.OperationID + "-result"
	
	html := fmt.Sprintf(`<div class="hd1-component"><h4>%s</h4><form id="%s">`, title, formId)
	
	// Add form fields based on method and path parameters
	paramCount := strings.Count(route.Path, "{")
	if paramCount > 0 {
		html += `<div class="form-field"><label for="param1">Parameter 1:</label><input type="text" name="param1" required></div>`
	}
	if paramCount > 1 {
		html += `<div class="form-field"><label for="param2">Parameter 2:</label><input type="text" name="param2" required></div>`
	}
	
	if route.Method == "POST" || route.Method == "PUT" {
		html += `<div class="form-field"><label for="data">Request Body (JSON):</label><textarea name="data" placeholder="{}"></textarea></div>`
	}
	
	html += fmt.Sprintf(`<button type="submit">Execute</button></form><div id="%s" class="result-area"></div></div>`, resultId)
	
	// Escape for JavaScript string
	html = strings.ReplaceAll(html, "'", "\\'")
	html = strings.ReplaceAll(html, "\n", "")
	
	return html
}

func getExecuteParams(route RouteInfo) string {
	return "formData"
}

func getAPIParams(route RouteInfo) string {
	paramCount := strings.Count(route.Path, "{")
	
	if paramCount == 0 {
		if route.Method == "POST" || route.Method == "PUT" {
			return "formData"
		}
		return ""
	} else if paramCount == 1 {
		if route.Method == "POST" || route.Method == "PUT" {
			return "formData.param1, formData"
		}
		return "formData.param1"
	} else {
		if route.Method == "POST" || route.Method == "PUT" {
			return "formData.param1, formData.param2, formData"
		}
		return "formData.param1, formData.param2"
	}
}

func getFormSchemaName(route RouteInfo) string {
	return route.OperationID + "Form"
}

func generateFormSchemaJSON(route RouteInfo) string {
	title := strings.Title(strings.ReplaceAll(route.OperationID, "_", " "))
	
	schema := fmt.Sprintf(`{
        "title": "%s",
        "submitText": "Execute %s",
        "fields": {`, title, route.Method)
	
	// Add path parameter fields
	paramCount := strings.Count(route.Path, "{")
	fields := []string{}
	
	if paramCount > 0 {
		fields = append(fields, `"param1": {"type": "string", "title": "Parameter 1", "required": true}`)
	}
	if paramCount > 1 {
		fields = append(fields, `"param2": {"type": "string", "title": "Parameter 2", "required": true}`)
	}
	
	if route.Method == "POST" || route.Method == "PUT" {
		fields = append(fields, `"data": {"type": "string", "title": "Request Body (JSON)", "placeholder": "{}"}`)
	}
	
	schema += strings.Join(fields, ", ")
	schema += "}}"
	
	return schema
}

// generateEnhancedIntegration creates A-Frame bridge functions
func generateEnhancedIntegration(spec OpenAPISpec, routes []RouteInfo) error {
	logging.Info("generating enhanced A-Frame integration", map[string]interface{}{
		"task": "upstream-downstream-api-bridge",
	})
	
	// Create enhanced shell functions
	if err := generateEnhancedShellFunctions(spec, routes); err != nil {
		return fmt.Errorf("failed to generate enhanced shell functions: %w", err)
	}
	
	// Create JavaScript function bridge
	if err := generateJavaScriptBridge(spec, routes); err != nil {
		return fmt.Errorf("failed to generate JavaScript bridge: %w", err)  
	}
	
	return nil
}

// generateEnhancedShellFunctions creates shell functions with A-Frame integration
func generateEnhancedShellFunctions(spec OpenAPISpec, routes []RouteInfo) error {
	outputDir := "/opt/hd1/lib"
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	
	// A-Frame capabilities mapping (used for documentation)
	_ = map[string]interface{}{
		"geometry_types": []string{"box", "sphere", "cylinder", "cone", "plane"},
		"light_types": []string{"directional", "point", "ambient", "spot"},
		"material_properties": []string{"color", "metalness", "roughness", "transparency", "emissive"},
		"physics_bodies": []string{"dynamic", "static", "kinematic"},
	}
	
	tmpl, err := loadTemplate("templates/shell/aframe-functions.tmpl")
	if err != nil {
		return fmt.Errorf("failed to load A-Frame shell template: %w", err)
	}

	outputPath := filepath.Join(outputDir, "downstream/aframelib.sh")
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create enhanced shell functions file: %w", err)
	}
	defer outputFile.Close()

	if err := tmpl.Execute(outputFile, nil); err != nil {
		return fmt.Errorf("failed to execute A-Frame shell template: %w", err)
	}
	
	// Set executable permissions
	if err := os.Chmod(outputPath, 0755); err != nil {
		return fmt.Errorf("failed to write enhanced shell functions: %w", err)
	}
	
	logging.Info("enhanced shell functions generated", map[string]interface{}{
		"output_path": outputPath,
		"aframe_integration": true,
	})
	
	return nil
}

// generateJavaScriptBridge creates JavaScript functions with identical signatures
func generateJavaScriptBridge(spec OpenAPISpec, routes []RouteInfo) error {
	outputDir := "/opt/hd1/lib"
	
	tmpl, err := loadTemplate("templates/javascript/aframe-bridge.tmpl")
	if err != nil {
		return fmt.Errorf("failed to load A-Frame bridge template: %w", err)
	}

	outputPath := filepath.Join(outputDir, "downstream/aframelib.js")
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create JavaScript bridge file: %w", err)
	}
	defer outputFile.Close()

	if err := tmpl.Execute(outputFile, nil); err != nil {
		return fmt.Errorf("failed to execute A-Frame bridge template: %w", err)
	}
	
	logging.Info("JavaScript function bridge generated", map[string]interface{}{
		"output_path": outputPath,
		"identical_signatures": true,
	})
	
	return nil
}

// generateCoreShellFunctions creates hd1-functions.sh from API specification
func generateCoreShellFunctions(spec *OpenAPISpec, routes []RouteInfo) error {
	outputDir := "/opt/hd1/lib"
	
	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	
	// Generate core shell function library
	tmpl, err := loadTemplate("templates/shell/core-functions.tmpl")
	if err != nil {
		return fmt.Errorf("failed to load core shell template: %w", err)
	}
	outputPath := filepath.Join(outputDir, "hd1lib.sh")
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create core shell functions file: %w", err)
	}
	defer outputFile.Close()

	if err := tmpl.Execute(outputFile, nil); err != nil {
		return fmt.Errorf("failed to execute core shell template: %w", err)
	}
	
	// Set executable permissions
	if err := os.Chmod(outputPath, 0755); err != nil {
		return fmt.Errorf("failed to write core shell functions: %w", err)
	}
	
	logging.Info("core shell functions generated", map[string]interface{}{
		"output_path": outputPath,
		"source": "api.yaml",
		"single_source_of_truth": true,
	})
	
	return nil
}