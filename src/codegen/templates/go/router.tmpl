// ===================================================================
// WARNING: AUTO-GENERATED CODE - DO NOT MODIFY THIS FILE
// ===================================================================
//
// This file is automatically generated from api.yaml specification.
// 
// ⚠️  CRITICAL WARNING: ALL MANUAL CHANGES WILL BE LOST ⚠️
//
// • This file is regenerated on every build
// • Changes made here are NON-PERSISTENT
// • Manual modifications will be OVERWRITTEN
// • To modify routing: Update api.yaml specification
//
// Generation Command: make generate
// Source File: /opt/hd1/src/api.yaml
// Generated: Auto-generated by HD1 specification-driven development
//
// ===================================================================
// SINGLE SOURCE OF TRUTH: api.yaml drives ALL routing
// ===================================================================
package main

import (
	"net/http"
	"strings"
	"holodeck1/logging"
{{range .Imports}}
	{{if eq . "holodeck1/api/logging"}}apiLogging "{{.}}"{{else}}"{{.}}"{{end}}{{end}}
)

// Route represents a single API route
type Route struct {
	Path       string
	Method     string
	Handler    func(http.ResponseWriter, *http.Request)
	OperationID string
}

// APIRouter manages all auto-generated routes
type APIRouter struct {
	routes []Route
	hub    *server.Hub
}

// NewAPIRouter creates router from specification
func NewAPIRouter(hub *server.Hub) *APIRouter {
	router := &APIRouter{hub: hub}
	router.generateRoutes()
	return router
}

// ServeHTTP implements http.Handler interface
func (r *APIRouter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	// Set CORS headers
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
	w.Header().Set("Content-Type", "application/json")

	if req.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	// Route matching with parameter extraction
	path := strings.TrimPrefix(req.URL.Path, "/api")
	for _, route := range r.routes {
		if r.matchRoute(route.Path, path) && route.Method == req.Method {
			logging.Debug("API request routed", map[string]interface{}{
				"method": req.Method,
				"path": req.URL.Path,
				"operation_id": route.OperationID,
			})
			route.Handler(w, req)
			return
		}
	}

	// Route not found
	http.Error(w, "API endpoint not found", http.StatusNotFound)
}

// Match route with parameter support (e.g. /sessions/{sessionId})
func (r *APIRouter) matchRoute(pattern, path string) bool {
	patternParts := strings.Split(strings.Trim(pattern, "/"), "/")
	pathParts := strings.Split(strings.Trim(path, "/"), "/")

	if len(patternParts) != len(pathParts) {
		return false
	}

	for i, part := range patternParts {
		if strings.HasPrefix(part, "{") && strings.HasSuffix(part, "}") {
			// Parameter placeholder - matches any value
			continue
		}
		if part != pathParts[i] {
			return false
		}
	}
	return true
}

// AUTO-GENERATED ROUTE DEFINITIONS
func (r *APIRouter) generateRoutes() {
	r.routes = []Route{
{{range .Routes}}
		{
			Path:       "{{.Path}}",
			Method:     "{{.Method}}",
			Handler:    r.{{.HandlerFunc}},
			OperationID: "{{.OperationID}}",
		},{{end}}
	}
}

{{range .HandlerStubs}}
// {{.Comment}}
func (r *APIRouter) {{.FuncName}}(w http.ResponseWriter, req *http.Request) {
	{{if eq .Package "logging"}}apiLogging{{else}}{{.Package}}{{end}}.{{if hasSuffix .FuncName "Handler"}}{{.FuncName}}{{else}}{{.FuncName}}Handler{{end}}(w, req, r.hub)
}
{{end}}